{"ast":null,"code":"import _extends from '@babel/runtime/helpers/esm/extends';\nimport { ShaderChunk } from 'three';\nconst pcss = function () {\n  let {\n    frustrum,\n    frustum = 3.75,\n    size = 0.005,\n    near = 9.5,\n    samples = 17,\n    rings = 11\n  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  return \"#define LIGHT_WORLD_SIZE \" + size + \"\\n#define LIGHT_FRUSTUM_WIDTH \" + (frustrum != null ? frustrum : frustum) + \"\\n#define LIGHT_SIZE_UV (LIGHT_WORLD_SIZE / LIGHT_FRUSTUM_WIDTH)\\n#define NEAR_PLANE \" + near + \"\\n\\n#define NUM_SAMPLES \" + samples + \"\\n#define NUM_RINGS \" + rings + \"\\n#define BLOCKER_SEARCH_NUM_SAMPLES NUM_SAMPLES\\n#define PCF_NUM_SAMPLES NUM_SAMPLES\\n\\nvec2 poissonDisk[NUM_SAMPLES];\\n\\nvoid initPoissonSamples(const in vec2 randomSeed) {\\n\\tfloat ANGLE_STEP = PI2 * float(NUM_RINGS) / float(NUM_SAMPLES);\\n\\tfloat INV_NUM_SAMPLES = 1.0 / float(NUM_SAMPLES);\\n\\tfloat angle = rand(randomSeed) * PI2;\\n\\tfloat radius = INV_NUM_SAMPLES;\\n\\tfloat radiusStep = radius;\\n\\tfor (int i = 0; i < NUM_SAMPLES; i++) {\\n\\t\\tpoissonDisk[i] = vec2(cos(angle), sin(angle)) * pow(radius, 0.75);\\n\\t\\tradius += radiusStep;\\n\\t\\tangle += ANGLE_STEP;\\n\\t}\\n}\\n\\nfloat penumbraSize(const in float zReceiver, const in float zBlocker) { // Parallel plane estimation\\n\\treturn (zReceiver - zBlocker) / zBlocker;\\n}\\n\\nfloat findBlocker(sampler2D shadowMap, const in vec2 uv, const in float zReceiver) {\\n\\tfloat searchRadius = LIGHT_SIZE_UV * (zReceiver - NEAR_PLANE) / zReceiver;\\n\\tfloat blockerDepthSum = 0.0;\\n\\tint numBlockers = 0;\\n\\tfor (int i = 0; i < BLOCKER_SEARCH_NUM_SAMPLES; i++) {\\n\\t\\tfloat shadowMapDepth = unpackRGBAToDepth(texture2D(shadowMap, uv + poissonDisk[i] * searchRadius));\\n\\t\\tif (shadowMapDepth < zReceiver) {\\n\\t\\t\\tblockerDepthSum += shadowMapDepth;\\n\\t\\t\\tnumBlockers++;\\n\\t\\t}\\n\\t}\\n\\tif (numBlockers == 0) return -1.0;\\n\\treturn blockerDepthSum / float(numBlockers);\\n}\\n\\nfloat PCF_Filter(sampler2D shadowMap, vec2 uv, float zReceiver, float filterRadius) {\\n\\tfloat sum = 0.0;\\n\\tfor (int i = 0; i < PCF_NUM_SAMPLES; i++) {\\n\\t\\tfloat depth = unpackRGBAToDepth(texture2D(shadowMap, uv + poissonDisk[ i ] * filterRadius));\\n\\t\\tif (zReceiver <= depth) sum += 1.0;\\n\\t}\\n\\tfor (int i = 0; i < PCF_NUM_SAMPLES; i++) {\\n\\t\\tfloat depth = unpackRGBAToDepth(texture2D(shadowMap, uv + -poissonDisk[ i ].yx * filterRadius));\\n\\t\\tif (zReceiver <= depth) sum += 1.0;\\n\\t}\\n\\treturn sum / (2.0 * float(PCF_NUM_SAMPLES));\\n}\\n\\nfloat PCSS(sampler2D shadowMap, vec4 coords) {\\n\\tvec2 uv = coords.xy;\\n\\tfloat zReceiver = coords.z; // Assumed to be eye-space z in this code\\n\\tinitPoissonSamples(uv);\\n\\tfloat avgBlockerDepth = findBlocker(shadowMap, uv, zReceiver);\\n\\tif (avgBlockerDepth == -1.0) return 1.0;\\n\\tfloat penumbraRatio = penumbraSize(zReceiver, avgBlockerDepth);\\n\\tfloat filterRadius = penumbraRatio * LIGHT_SIZE_UV * NEAR_PLANE / zReceiver;\\n\\treturn PCF_Filter(shadowMap, uv, zReceiver, filterRadius);\\n}\";\n};\nlet deployed = false;\nconst softShadows = props => {\n  // Avoid adding the effect twice, which may happen in HMR scenarios\n  if (!deployed) {\n    if (props == null ? void 0 : props.frustrum) {\n      console.warn('You have used an incorrect spelling of frustrum, this will be deprecated in the future');\n    }\n    deployed = true;\n    let shader = ShaderChunk.shadowmap_pars_fragment;\n    shader = shader.replace('#ifdef USE_SHADOWMAP', '#ifdef USE_SHADOWMAP\\n' + pcss(_extends({}, props)));\n    shader = shader.replace('#if defined( SHADOWMAP_TYPE_PCF )', '\\nreturn PCSS(shadowMap, shadowCoord);\\n#if defined( SHADOWMAP_TYPE_PCF )');\n    ShaderChunk.shadowmap_pars_fragment = shader;\n  }\n};\nexport { softShadows };","map":{"version":3,"names":["_extends","ShaderChunk","pcss","frustrum","frustum","size","near","samples","rings","arguments","length","undefined","deployed","softShadows","props","console","warn","shader","shadowmap_pars_fragment","replace"],"sources":["/Users/mitchellkimbell/Desktop/space-frontend/node_modules/@react-three/drei/core/softShadows.js"],"sourcesContent":["import _extends from '@babel/runtime/helpers/esm/extends';\nimport { ShaderChunk } from 'three';\n\nconst pcss = ({\n  frustrum,\n  frustum = 3.75,\n  size = 0.005,\n  near = 9.5,\n  samples = 17,\n  rings = 11\n} = {}) => \"#define LIGHT_WORLD_SIZE \" + size + \"\\n#define LIGHT_FRUSTUM_WIDTH \" + (frustrum != null ? frustrum : frustum) + \"\\n#define LIGHT_SIZE_UV (LIGHT_WORLD_SIZE / LIGHT_FRUSTUM_WIDTH)\\n#define NEAR_PLANE \" + near + \"\\n\\n#define NUM_SAMPLES \" + samples + \"\\n#define NUM_RINGS \" + rings + \"\\n#define BLOCKER_SEARCH_NUM_SAMPLES NUM_SAMPLES\\n#define PCF_NUM_SAMPLES NUM_SAMPLES\\n\\nvec2 poissonDisk[NUM_SAMPLES];\\n\\nvoid initPoissonSamples(const in vec2 randomSeed) {\\n\\tfloat ANGLE_STEP = PI2 * float(NUM_RINGS) / float(NUM_SAMPLES);\\n\\tfloat INV_NUM_SAMPLES = 1.0 / float(NUM_SAMPLES);\\n\\tfloat angle = rand(randomSeed) * PI2;\\n\\tfloat radius = INV_NUM_SAMPLES;\\n\\tfloat radiusStep = radius;\\n\\tfor (int i = 0; i < NUM_SAMPLES; i++) {\\n\\t\\tpoissonDisk[i] = vec2(cos(angle), sin(angle)) * pow(radius, 0.75);\\n\\t\\tradius += radiusStep;\\n\\t\\tangle += ANGLE_STEP;\\n\\t}\\n}\\n\\nfloat penumbraSize(const in float zReceiver, const in float zBlocker) { // Parallel plane estimation\\n\\treturn (zReceiver - zBlocker) / zBlocker;\\n}\\n\\nfloat findBlocker(sampler2D shadowMap, const in vec2 uv, const in float zReceiver) {\\n\\tfloat searchRadius = LIGHT_SIZE_UV * (zReceiver - NEAR_PLANE) / zReceiver;\\n\\tfloat blockerDepthSum = 0.0;\\n\\tint numBlockers = 0;\\n\\tfor (int i = 0; i < BLOCKER_SEARCH_NUM_SAMPLES; i++) {\\n\\t\\tfloat shadowMapDepth = unpackRGBAToDepth(texture2D(shadowMap, uv + poissonDisk[i] * searchRadius));\\n\\t\\tif (shadowMapDepth < zReceiver) {\\n\\t\\t\\tblockerDepthSum += shadowMapDepth;\\n\\t\\t\\tnumBlockers++;\\n\\t\\t}\\n\\t}\\n\\tif (numBlockers == 0) return -1.0;\\n\\treturn blockerDepthSum / float(numBlockers);\\n}\\n\\nfloat PCF_Filter(sampler2D shadowMap, vec2 uv, float zReceiver, float filterRadius) {\\n\\tfloat sum = 0.0;\\n\\tfor (int i = 0; i < PCF_NUM_SAMPLES; i++) {\\n\\t\\tfloat depth = unpackRGBAToDepth(texture2D(shadowMap, uv + poissonDisk[ i ] * filterRadius));\\n\\t\\tif (zReceiver <= depth) sum += 1.0;\\n\\t}\\n\\tfor (int i = 0; i < PCF_NUM_SAMPLES; i++) {\\n\\t\\tfloat depth = unpackRGBAToDepth(texture2D(shadowMap, uv + -poissonDisk[ i ].yx * filterRadius));\\n\\t\\tif (zReceiver <= depth) sum += 1.0;\\n\\t}\\n\\treturn sum / (2.0 * float(PCF_NUM_SAMPLES));\\n}\\n\\nfloat PCSS(sampler2D shadowMap, vec4 coords) {\\n\\tvec2 uv = coords.xy;\\n\\tfloat zReceiver = coords.z; // Assumed to be eye-space z in this code\\n\\tinitPoissonSamples(uv);\\n\\tfloat avgBlockerDepth = findBlocker(shadowMap, uv, zReceiver);\\n\\tif (avgBlockerDepth == -1.0) return 1.0;\\n\\tfloat penumbraRatio = penumbraSize(zReceiver, avgBlockerDepth);\\n\\tfloat filterRadius = penumbraRatio * LIGHT_SIZE_UV * NEAR_PLANE / zReceiver;\\n\\treturn PCF_Filter(shadowMap, uv, zReceiver, filterRadius);\\n}\";\n\nlet deployed = false;\nconst softShadows = props => {\n  // Avoid adding the effect twice, which may happen in HMR scenarios\n  if (!deployed) {\n    if (props == null ? void 0 : props.frustrum) {\n      console.warn('You have used an incorrect spelling of frustrum, this will be deprecated in the future');\n    }\n\n    deployed = true;\n    let shader = ShaderChunk.shadowmap_pars_fragment;\n    shader = shader.replace('#ifdef USE_SHADOWMAP', '#ifdef USE_SHADOWMAP\\n' + pcss(_extends({}, props)));\n    shader = shader.replace('#if defined( SHADOWMAP_TYPE_PCF )', '\\nreturn PCSS(shadowMap, shadowCoord);\\n#if defined( SHADOWMAP_TYPE_PCF )');\n    ShaderChunk.shadowmap_pars_fragment = shader;\n  }\n};\n\nexport { softShadows };\n"],"mappings":"AAAA,OAAOA,QAAQ,MAAM,oCAAoC;AACzD,SAASC,WAAW,QAAQ,OAAO;AAEnC,MAAMC,IAAI,GAAG,SAAAA,CAAA;EAAA,IAAC;IACZC,QAAQ;IACRC,OAAO,GAAG,IAAI;IACdC,IAAI,GAAG,KAAK;IACZC,IAAI,GAAG,GAAG;IACVC,OAAO,GAAG,EAAE;IACZC,KAAK,GAAG;EACV,CAAC,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,CAAC,CAAC;EAAA,OAAK,2BAA2B,GAAGJ,IAAI,GAAG,gCAAgC,IAAIF,QAAQ,IAAI,IAAI,GAAGA,QAAQ,GAAGC,OAAO,CAAC,GAAG,uFAAuF,GAAGE,IAAI,GAAG,0BAA0B,GAAGC,OAAO,GAAG,sBAAsB,GAAGC,KAAK,GAAG,yzEAAyzE;AAAA;AAE/lF,IAAII,QAAQ,GAAG,KAAK;AACpB,MAAMC,WAAW,GAAGC,KAAK,IAAI;EAC3B;EACA,IAAI,CAACF,QAAQ,EAAE;IACb,IAAIE,KAAK,IAAI,IAAI,GAAG,KAAK,CAAC,GAAGA,KAAK,CAACX,QAAQ,EAAE;MAC3CY,OAAO,CAACC,IAAI,CAAC,wFAAwF,CAAC;IACxG;IAEAJ,QAAQ,GAAG,IAAI;IACf,IAAIK,MAAM,GAAGhB,WAAW,CAACiB,uBAAuB;IAChDD,MAAM,GAAGA,MAAM,CAACE,OAAO,CAAC,sBAAsB,EAAE,wBAAwB,GAAGjB,IAAI,CAACF,QAAQ,CAAC,CAAC,CAAC,EAAEc,KAAK,CAAC,CAAC,CAAC;IACrGG,MAAM,GAAGA,MAAM,CAACE,OAAO,CAAC,mCAAmC,EAAE,2EAA2E,CAAC;IACzIlB,WAAW,CAACiB,uBAAuB,GAAGD,MAAM;EAC9C;AACF,CAAC;AAED,SAASJ,WAAW"},"metadata":{},"sourceType":"module"}